<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Mix Jump</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #1a1a2e; }
#game-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
canvas { display: block; max-width: 100%; max-height: 100%; }
</style>
</head>
<body>
<div id="game-container"></div>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
<script>
// === Color Mix Jump ===
// Hyper-casual game: jump on colored platforms to mix RYB colors and match the target!

const GAME_WIDTH = 400;
const GAME_HEIGHT = 700;
const PLATFORM_COUNT = 8;
const PLATFORM_SPACING_MIN = 80;
const PLATFORM_SPACING_MAX = 130;
const JUMP_VELOCITY = -550;
const GRAVITY = 800;
const MOVE_SPEED = 200;

// RYB color system
const COLORS = {
  red:    { hex: 0xff6b6b, name: 'Îπ®Í∞ï', css: '#ff6b6b' },
  yellow: { hex: 0xffd43b, name: 'ÎÖ∏Îûë', css: '#ffd43b' },
  blue:   { hex: 0x339af0, name: 'ÌååÎûë', css: '#339af0' },
  // Mixed colors
  orange: { hex: 0xff9f43, name: 'Ï£ºÌô©', css: '#ff9f43' },
  green:  { hex: 0x51cf66, name: 'Ï¥àÎ°ù', css: '#51cf66' },
  purple: { hex: 0xcc5de8, name: 'Î≥¥Îùº', css: '#cc5de8' },
  // Neutral
  none:   { hex: 0xcccccc, name: 'Î¨¥ÏÉâ', css: '#cccccc' },
  muddy:  { hex: 0x8b7355, name: 'ÌÉÅÌïúÏÉâ', css: '#8b7355' },
};

const PRIMARY_COLORS = ['red', 'yellow', 'blue'];

// RYB mixing rules
function mixColors(color1, color2) {
  if (color1 === 'none') return color2;
  if (color2 === 'none') return color1;
  if (color1 === color2) return color1;

  const pair = [color1, color2].sort().join('+');
  const mixMap = {
    'blue+red': 'purple',
    'red+yellow': 'orange',
    'blue+yellow': 'green',
  };

  return mixMap[pair] || 'muddy';
}

// Stages: each has a target color
const STAGES = [
  { target: 'purple', hint: 'Îπ®Í∞ï + ÌååÎûë', stageNum: 1 },
  { target: 'orange', hint: 'Îπ®Í∞ï + ÎÖ∏Îûë', stageNum: 2 },
  { target: 'green',  hint: 'ÌååÎûë + ÎÖ∏Îûë', stageNum: 3 },
  { target: 'purple', hint: 'Îπ®Í∞ï + ÌååÎûë', stageNum: 4, harder: true },
  { target: 'orange', hint: 'Îπ®Í∞ï + ÎÖ∏Îûë', stageNum: 5, harder: true },
  { target: 'green',  hint: 'ÌååÎûë + ÎÖ∏Îûë', stageNum: 6, harder: true },
];

class GameScene extends Phaser.Scene {
  constructor() {
    super({ key: 'GameScene' });
  }

  init(data) {
    this.stageIndex = data.stageIndex || 0;
    this.score = data.score || 0;
    this.combo = data.combo || 0;
  }

  create() {
    const stage = STAGES[this.stageIndex % STAGES.length];
    this.currentStage = stage;
    this.playerColor = 'none';
    this.isGameOver = false;
    this.hasLanded = false;
    this.highestY = GAME_HEIGHT;

    // Pastel gradient background
    this.createBackground();

    // Floating particles
    this.createParticles();

    // Platforms group
    this.platforms = this.physics.add.staticGroup();

    // Starting platform (neutral)
    this.createPlatform(GAME_WIDTH / 2, GAME_HEIGHT - 80, 'none', true);

    // Generate colored platforms going up
    this.generatePlatforms();

    // Goal platform at top
    this.goalY = this.highestPlatformY - 120;
    this.goalPlatform = this.createPlatform(GAME_WIDTH / 2, this.goalY, 'goal', false, true);

    // Player (slime)
    this.createPlayer();

    // Physics
    this.physics.add.collider(this.player, this.platforms, this.onPlatformLand, null, this);

    // Controls
    this.setupControls();

    // UI
    this.createUI(stage);

    // Camera follows player upward
    this.cameras.main.setBounds(0, this.goalY - 200, GAME_WIDTH, GAME_HEIGHT - this.goalY + 400);
    this.cameras.main.startFollow(this.player, false, 0, 0.1, 0, 100);

    // Death zone at bottom
    this.deathY = GAME_HEIGHT + 100;
  }

  createBackground() {
    const bg = this.add.graphics();
    // Gradient from lavender to sky blue
    for (let i = 0; i < GAME_HEIGHT * 3; i++) {
      const t = i / (GAME_HEIGHT * 3);
      const r = Phaser.Math.Interpolation.Linear([224, 142], t);
      const g = Phaser.Math.Interpolation.Linear([195, 197], t);
      const b = Phaser.Math.Interpolation.Linear([252, 252], t);
      bg.fillStyle(Phaser.Display.Color.GetColor(r, g, b), 1);
      bg.fillRect(0, -GAME_HEIGHT * 2 + i, GAME_WIDTH, 1);
    }
    bg.setScrollFactor(0.3);

    // Clouds
    for (let i = 0; i < 8; i++) {
      const cx = Phaser.Math.Between(30, GAME_WIDTH - 30);
      const cy = Phaser.Math.Between(-GAME_HEIGHT, GAME_HEIGHT);
      const cloud = this.add.ellipse(cx, cy, Phaser.Math.Between(60, 140), Phaser.Math.Between(30, 60), 0xffffff, 0.25);
      cloud.setScrollFactor(0.2);
    }
  }

  createParticles() {
    // Sparkle stars
    for (let i = 0; i < 20; i++) {
      const x = Phaser.Math.Between(10, GAME_WIDTH - 10);
      const y = Phaser.Math.Between(-GAME_HEIGHT * 2, GAME_HEIGHT);
      const star = this.add.circle(x, y, Phaser.Math.Between(1, 3), 0xffffff, Phaser.Math.FloatBetween(0.3, 0.8));
      star.setScrollFactor(0.4);
      this.tweens.add({
        targets: star,
        alpha: { from: star.alpha, to: 0.1 },
        duration: Phaser.Math.Between(1000, 3000),
        yoyo: true,
        repeat: -1,
      });
    }
  }

  createPlatform(x, y, color, isStart = false, isGoal = false) {
    const width = isGoal ? 100 : (isStart ? 120 : 80);
    const height = 22;

    const container = this.add.container(x, y);

    if (isGoal) {
      // Goal platform ‚Äî shows target color
      const targetColor = COLORS[this.currentStage.target];
      const glow = this.add.ellipse(0, 0, width + 20, height + 16, targetColor.hex, 0.3);
      const body = this.add.ellipse(0, 0, width, height, targetColor.hex, 0.9);
      const shine = this.add.ellipse(0, -4, width * 0.7, height * 0.4, 0xffffff, 0.35);
      const star = this.add.text(0, -24, '‚òÖ', { fontSize: '18px', color: targetColor.css }).setOrigin(0.5);
      container.add([glow, body, shine, star]);

      this.tweens.add({
        targets: glow,
        scaleX: 1.15,
        scaleY: 1.15,
        alpha: 0.15,
        duration: 800,
        yoyo: true,
        repeat: -1,
      });
    } else {
      // Normal platform
      const colorData = color === 'none' ? { hex: 0xdddddd } : COLORS[color];
      const body = this.add.ellipse(0, 0, width, height, colorData.hex, 1);
      const shine = this.add.ellipse(0, -4, width * 0.7, height * 0.4, 0xffffff, 0.3);
      container.add([body, shine]);

      if (!isStart && color !== 'none') {
        // Jelly bounce animation
        this.tweens.add({
          targets: container,
          scaleY: { from: 1, to: 0.92 },
          duration: 1200,
          yoyo: true,
          repeat: -1,
          ease: 'Sine.easeInOut',
        });
      }
    }

    // Physics body
    const zone = this.add.zone(x, y, width, height);
    this.physics.add.existing(zone, true);
    zone.body.setSize(width, height * 0.6);
    zone.body.setOffset(-width / 2, -height * 0.3);
    zone.platformColor = color;
    zone.isGoal = isGoal;
    zone.container = container;
    this.platforms.add(zone);

    return zone;
  }

  generatePlatforms() {
    let y = GAME_HEIGHT - 200;
    const harder = this.currentStage.harder;

    for (let i = 0; i < PLATFORM_COUNT; i++) {
      const spacing = Phaser.Math.Between(
        harder ? PLATFORM_SPACING_MIN + 20 : PLATFORM_SPACING_MIN,
        harder ? PLATFORM_SPACING_MAX + 30 : PLATFORM_SPACING_MAX
      );
      y -= spacing;
      const x = Phaser.Math.Between(60, GAME_WIDTH - 60);
      const color = Phaser.Math.RND.pick(PRIMARY_COLORS);
      this.createPlatform(x, y, color);
    }
    this.highestPlatformY = y;
  }

  createPlayer() {
    const startX = GAME_WIDTH / 2;
    const startY = GAME_HEIGHT - 120;

    // Player container
    this.player = this.add.container(startX, startY);

    // Slime body
    this.slimeBody = this.add.ellipse(0, 0, 36, 30, COLORS.none.hex, 0.85);
    // Eyes
    const eyeL = this.add.ellipse(-8, -4, 8, 10, 0xffffff, 0.95);
    const eyeR = this.add.ellipse(8, -4, 8, 10, 0xffffff, 0.95);
    const pupilL = this.add.circle(-7, -3, 3, 0x333333);
    const pupilR = this.add.circle(9, -3, 3, 0x333333);
    // Mouth
    const mouth = this.add.ellipse(0, 6, 12, 5, 0x000000, 0.15);
    // Glow ring
    this.slimeGlow = this.add.ellipse(0, 0, 44, 36, 0xffffff, 0.15);

    this.player.add([this.slimeGlow, this.slimeBody, eyeL, eyeR, pupilL, pupilR, mouth]);

    // Physics
    this.physics.world.enable(this.player);
    this.player.body.setSize(30, 28);
    this.player.body.setOffset(-15, -14);
    this.player.body.setGravityY(GRAVITY);
    this.player.body.setBounce(0);
    this.player.body.setCollideWorldBounds(false);
    this.player.body.setMaxVelocity(400, 800);
    this.player.setDepth(10);
  }

  setupControls() {
    // Touch/click to jump, drag left/right to move
    this.input.on('pointerdown', (pointer) => {
      if (this.isGameOver) return;
      if (this.player.body.touching.down || this.hasLanded) {
        this.doJump();
      }
      this.pointerStartX = pointer.x;
    });

    this.input.on('pointermove', (pointer) => {
      if (this.isGameOver) return;
      if (pointer.isDown) {
        const dx = pointer.x - this.pointerStartX;
        this.player.body.setVelocityX(dx * 3);
      }
    });

    this.input.on('pointerup', () => {
      if (this.isGameOver) return;
      this.player.body.setVelocityX(0);
    });

    // Keyboard
    this.cursors = this.input.keyboard.createCursorKeys();
    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
  }

  doJump() {
    this.player.body.setVelocityY(JUMP_VELOCITY);
    this.hasLanded = false;

    // Squash & stretch
    this.tweens.add({
      targets: this.player,
      scaleX: 0.85,
      scaleY: 1.2,
      duration: 100,
      yoyo: true,
      ease: 'Quad.easeOut',
    });
  }

  onPlatformLand(player, platform) {
    // Only land from above
    if (player.body.velocity.y <= 0) return;

    this.hasLanded = true;

    // Landing squash
    this.tweens.add({
      targets: this.player,
      scaleX: 1.2,
      scaleY: 0.8,
      duration: 80,
      yoyo: true,
      ease: 'Quad.easeOut',
    });

    if (platform.isGoal) {
      this.checkGoal(platform);
      return;
    }

    const platColor = platform.platformColor;
    if (platColor && platColor !== 'none') {
      const oldColor = this.playerColor;
      this.playerColor = mixColors(this.playerColor, platColor);
      this.updatePlayerColor();

      // Color splash effect
      this.createColorSplash(player.x, player.y, COLORS[platColor].hex);

      // Platform bounce effect
      if (platform.container) {
        this.tweens.add({
          targets: platform.container,
          scaleX: 1.3,
          scaleY: 0.7,
          duration: 100,
          yoyo: true,
        });
      }
    }

    // Auto-jump on land for mobile-friendly play
    this.time.delayedCall(50, () => {
      if (this.hasLanded && !this.isGameOver) {
        // Don't auto-jump, wait for tap
      }
    });
  }

  checkGoal(platform) {
    if (this.playerColor === this.currentStage.target) {
      // Success!
      this.combo++;
      this.score += 100 * this.combo;
      this.createSuccessEffect(this.player.x, this.player.y);
      this.isGameOver = true;

      // Show success text
      const successText = this.add.text(GAME_WIDTH / 2, this.player.y - 60, 'ÌÅ¥Î¶¨Ïñ¥! ‚òÖ', {
        fontSize: '32px',
        fontFamily: 'Arial, sans-serif',
        color: '#ffffff',
        stroke: '#000000',
        strokeThickness: 4,
      }).setOrigin(0.5).setDepth(100);

      const scoreText = this.add.text(GAME_WIDTH / 2, this.player.y - 20, `+${100 * this.combo} (x${this.combo} ÏΩ§Î≥¥!)`, {
        fontSize: '20px',
        fontFamily: 'Arial, sans-serif',
        color: '#ffd43b',
        stroke: '#000000',
        strokeThickness: 3,
      }).setOrigin(0.5).setDepth(100);

      this.tweens.add({
        targets: [successText, scoreText],
        y: '-=30',
        alpha: 0,
        duration: 1500,
        ease: 'Quad.easeOut',
      });

      // Next stage
      this.time.delayedCall(1500, () => {
        this.scene.restart({
          stageIndex: this.stageIndex + 1,
          score: this.score,
          combo: this.combo,
        });
      });
    } else {
      // Wrong color ‚Äî muddy reset
      this.combo = 0;
      this.playerColor = 'muddy';
      this.updatePlayerColor();

      const failText = this.add.text(GAME_WIDTH / 2, this.player.y - 50, 'ÏÉâÏù¥ Ïïà ÎßûÏïÑ!', {
        fontSize: '24px',
        fontFamily: 'Arial, sans-serif',
        color: '#ff6b6b',
        stroke: '#000000',
        strokeThickness: 3,
      }).setOrigin(0.5).setDepth(100);

      this.tweens.add({
        targets: failText,
        y: '-=40',
        alpha: 0,
        duration: 1200,
      });

      // Reset player color after a moment
      this.time.delayedCall(800, () => {
        this.playerColor = 'none';
        this.updatePlayerColor();
      });
    }
  }

  updatePlayerColor() {
    const colorData = COLORS[this.playerColor] || COLORS.none;
    this.slimeBody.setFillStyle(colorData.hex, 0.85);
    this.slimeGlow.setFillStyle(colorData.hex, 0.2);

    // Update color indicator
    if (this.colorIndicator) {
      this.colorIndicator.setFillStyle(colorData.hex);
    }
    if (this.colorLabel) {
      this.colorLabel.setText(colorData.name);
    }
  }

  createColorSplash(x, y, color) {
    for (let i = 0; i < 8; i++) {
      const particle = this.add.circle(x, y, Phaser.Math.Between(3, 7), color, 0.8);
      particle.setDepth(5);
      const angle = (Math.PI * 2 * i) / 8;
      const dist = Phaser.Math.Between(20, 50);
      this.tweens.add({
        targets: particle,
        x: x + Math.cos(angle) * dist,
        y: y + Math.sin(angle) * dist,
        alpha: 0,
        scaleX: 0.2,
        scaleY: 0.2,
        duration: 400,
        ease: 'Quad.easeOut',
        onComplete: () => particle.destroy(),
      });
    }
  }

  createSuccessEffect(x, y) {
    // Rainbow burst
    const rainbowColors = [0xff6b6b, 0xff9f43, 0xffd43b, 0x51cf66, 0x339af0, 0xcc5de8];
    for (let i = 0; i < 18; i++) {
      const c = rainbowColors[i % rainbowColors.length];
      const particle = this.add.circle(x, y, Phaser.Math.Between(3, 8), c, 0.9);
      particle.setDepth(20);
      const angle = (Math.PI * 2 * i) / 18;
      const dist = Phaser.Math.Between(40, 100);
      this.tweens.add({
        targets: particle,
        x: x + Math.cos(angle) * dist,
        y: y + Math.sin(angle) * dist,
        alpha: 0,
        duration: 800,
        ease: 'Quad.easeOut',
        onComplete: () => particle.destroy(),
      });
    }
  }

  createUI(stage) {
    const targetColor = COLORS[stage.target];

    // Top bar background
    const uiBg = this.add.rectangle(GAME_WIDTH / 2, 30, GAME_WIDTH - 20, 50, 0x000000, 0.3);
    uiBg.setScrollFactor(0).setDepth(50);

    // Stage text
    const stageText = this.add.text(15, 14, `Stage ${stage.stageNum}`, {
      fontSize: '14px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
    }).setScrollFactor(0).setDepth(51);

    // Target color display
    const targetLabel = this.add.text(GAME_WIDTH / 2, 14, 'Î™©Ìëú:', {
      fontSize: '14px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
    }).setOrigin(0.5, 0).setScrollFactor(0).setDepth(51);

    const targetCircle = this.add.circle(GAME_WIDTH / 2 - 20, 40, 10, targetColor.hex);
    targetCircle.setScrollFactor(0).setDepth(51);
    const targetName = this.add.text(GAME_WIDTH / 2 - 5, 34, targetColor.name, {
      fontSize: '13px',
      fontFamily: 'Arial, sans-serif',
      color: targetColor.css,
    }).setScrollFactor(0).setDepth(51);

    // Score
    this.scoreText = this.add.text(GAME_WIDTH - 15, 14, `Ï†êÏàò: ${this.score}`, {
      fontSize: '14px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
    }).setOrigin(1, 0).setScrollFactor(0).setDepth(51);

    // Current color indicator (bottom)
    const bottomBg = this.add.rectangle(GAME_WIDTH / 2, GAME_HEIGHT - 25, 140, 36, 0x000000, 0.3);
    bottomBg.setScrollFactor(0).setDepth(50);

    const myLabel = this.add.text(GAME_WIDTH / 2 - 55, GAME_HEIGHT - 33, 'ÎÇ¥ ÏÉâ:', {
      fontSize: '13px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
    }).setScrollFactor(0).setDepth(51);

    this.colorIndicator = this.add.circle(GAME_WIDTH / 2 + 5, GAME_HEIGHT - 25, 10, COLORS.none.hex);
    this.colorIndicator.setScrollFactor(0).setDepth(51);

    this.colorLabel = this.add.text(GAME_WIDTH / 2 + 20, GAME_HEIGHT - 32, COLORS.none.name, {
      fontSize: '13px',
      fontFamily: 'Arial, sans-serif',
      color: '#cccccc',
    }).setScrollFactor(0).setDepth(51);

    // Hint text
    const hint = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT - 60, `ÌûåÌä∏: ${stage.hint}`, {
      fontSize: '12px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
      alpha: 0.5,
    }).setOrigin(0.5).setScrollFactor(0).setDepth(51);

    this.tweens.add({
      targets: hint,
      alpha: 0,
      delay: 3000,
      duration: 1000,
    });
  }

  update() {
    if (this.isGameOver) return;

    // Keyboard movement
    if (this.cursors.left.isDown) {
      this.player.body.setVelocityX(-MOVE_SPEED);
    } else if (this.cursors.right.isDown) {
      this.player.body.setVelocityX(MOVE_SPEED);
    }

    // Keyboard jump
    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) || Phaser.Input.Keyboard.JustDown(this.cursors.up)) {
      if (this.hasLanded) {
        this.doJump();
      }
    }

    // Wrap horizontally
    if (this.player.x < -20) this.player.x = GAME_WIDTH + 20;
    if (this.player.x > GAME_WIDTH + 20) this.player.x = -20;

    // Fall death
    const camBottom = this.cameras.main.scrollY + GAME_HEIGHT;
    if (this.player.y > camBottom + 50) {
      this.gameOver();
    }

    // Update score display
    if (this.scoreText) {
      this.scoreText.setText(`Ï†êÏàò: ${this.score}`);
    }
  }

  gameOver() {
    if (this.isGameOver) return;
    this.isGameOver = true;
    this.combo = 0;

    // Screen flash
    this.cameras.main.flash(300, 255, 100, 100);

    const goText = this.add.text(GAME_WIDTH / 2, this.cameras.main.scrollY + GAME_HEIGHT / 2 - 30, 'Îñ®Ïñ¥Ï°åÎã§!', {
      fontSize: '36px',
      fontFamily: 'Arial, sans-serif',
      color: '#ff6b6b',
      stroke: '#000000',
      strokeThickness: 4,
    }).setOrigin(0.5).setDepth(100);

    const finalScore = this.add.text(GAME_WIDTH / 2, this.cameras.main.scrollY + GAME_HEIGHT / 2 + 20, `Ï†êÏàò: ${this.score}`, {
      fontSize: '22px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
      stroke: '#000000',
      strokeThickness: 3,
    }).setOrigin(0.5).setDepth(100);

    const retry = this.add.text(GAME_WIDTH / 2, this.cameras.main.scrollY + GAME_HEIGHT / 2 + 60, 'ÌÉ≠ÌïòÏó¨ Ïû¨ÏãúÏûë', {
      fontSize: '18px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffd43b',
    }).setOrigin(0.5).setDepth(100);

    this.tweens.add({
      targets: retry,
      alpha: 0.3,
      duration: 600,
      yoyo: true,
      repeat: -1,
    });

    this.time.delayedCall(800, () => {
      this.input.once('pointerdown', () => {
        this.scene.restart({ stageIndex: this.stageIndex, score: 0, combo: 0 });
      });
    });
  }
}

class TitleScene extends Phaser.Scene {
  constructor() {
    super({ key: 'TitleScene' });
  }

  create() {
    // Background
    const bg = this.add.graphics();
    for (let i = 0; i < GAME_HEIGHT; i++) {
      const t = i / GAME_HEIGHT;
      const r = Phaser.Math.Interpolation.Linear([224, 142], t);
      const g = Phaser.Math.Interpolation.Linear([195, 197], t);
      const b = Phaser.Math.Interpolation.Linear([252, 252], t);
      bg.fillStyle(Phaser.Display.Color.GetColor(r, g, b), 1);
      bg.fillRect(0, i, GAME_WIDTH, 1);
    }

    // Floating color circles
    const demoColors = [0xff6b6b, 0xffd43b, 0x339af0, 0xcc5de8, 0xff9f43, 0x51cf66];
    for (let i = 0; i < 12; i++) {
      const c = demoColors[i % demoColors.length];
      const circle = this.add.circle(
        Phaser.Math.Between(30, GAME_WIDTH - 30),
        Phaser.Math.Between(100, GAME_HEIGHT - 100),
        Phaser.Math.Between(10, 30),
        c, 0.2
      );
      this.tweens.add({
        targets: circle,
        y: circle.y + Phaser.Math.Between(-40, 40),
        x: circle.x + Phaser.Math.Between(-20, 20),
        duration: Phaser.Math.Between(2000, 4000),
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut',
      });
    }

    // Title
    const title = this.add.text(GAME_WIDTH / 2, 200, 'Color Mix\nJump', {
      fontSize: '52px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
      stroke: '#cc5de8',
      strokeThickness: 5,
      align: 'center',
      lineSpacing: 8,
    }).setOrigin(0.5);

    this.tweens.add({
      targets: title,
      scaleX: 1.05,
      scaleY: 1.05,
      duration: 1500,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut',
    });

    // Subtitle
    this.add.text(GAME_WIDTH / 2, 310, 'ÏÉâÍπîÏùÑ ÏÑûÏñ¥ Î™©Ìëú ÏÉâÏÉÅÏùÑ ÎßåÎì§Ïñ¥Ïöî!', {
      fontSize: '15px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
      alpha: 0.8,
    }).setOrigin(0.5);

    // Color mixing demo
    const demoY = 380;
    this.add.circle(GAME_WIDTH / 2 - 60, demoY, 16, COLORS.red.hex);
    this.add.text(GAME_WIDTH / 2 - 30, demoY - 6, '+', { fontSize: '18px', color: '#fff' }).setOrigin(0.5);
    this.add.circle(GAME_WIDTH / 2, demoY, 16, COLORS.blue.hex);
    this.add.text(GAME_WIDTH / 2 + 30, demoY - 6, '=', { fontSize: '18px', color: '#fff' }).setOrigin(0.5);
    this.add.circle(GAME_WIDTH / 2 + 60, demoY, 16, COLORS.purple.hex);

    // Slime character preview
    const slime = this.add.ellipse(GAME_WIDTH / 2, 470, 50, 40, 0xcc5de8, 0.8);
    const eyeL = this.add.ellipse(GAME_WIDTH / 2 - 10, 464, 10, 13, 0xffffff, 0.95);
    const eyeR = this.add.ellipse(GAME_WIDTH / 2 + 10, 464, 10, 13, 0xffffff, 0.95);
    this.add.circle(GAME_WIDTH / 2 - 9, 465, 4, 0x333333);
    this.add.circle(GAME_WIDTH / 2 + 11, 465, 4, 0x333333);

    this.tweens.add({
      targets: [slime, eyeL, eyeR],
      y: '-=12',
      duration: 600,
      yoyo: true,
      repeat: -1,
      ease: 'Quad.easeOut',
    });

    // Start button
    const startBtn = this.add.rectangle(GAME_WIDTH / 2, 560, 180, 50, 0xcc5de8, 0.9);
    const startText = this.add.text(GAME_WIDTH / 2, 560, 'ÏãúÏûëÌïòÍ∏∞', {
      fontSize: '22px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
      fontStyle: 'bold',
    }).setOrigin(0.5);

    this.tweens.add({
      targets: [startBtn, startText],
      scaleX: 1.05,
      scaleY: 1.05,
      duration: 800,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut',
    });

    // Controls hint
    this.add.text(GAME_WIDTH / 2, 620, 'ÌÉ≠: Ï†êÌîÑ | ÎìúÎûòÍ∑∏: Ïù¥Îèô | ‚Üê ‚Üí: Ïù¥Îèô', {
      fontSize: '12px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
      alpha: 0.5,
    }).setOrigin(0.5);

    // Credit
    this.add.text(GAME_WIDTH / 2, GAME_HEIGHT - 20, 'üê∞ Ï∏ÑÎ¶≠Ìïë + ü¶ä Í∑∏Î¶ºÌïë + üê• ÎßâÎÇ¥Ìïë', {
      fontSize: '11px',
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
      alpha: 0.4,
    }).setOrigin(0.5);

    startBtn.setInteractive({ useHandCursor: true });
    startBtn.on('pointerdown', () => {
      this.scene.start('GameScene', { stageIndex: 0, score: 0, combo: 0 });
    });

    this.input.keyboard.on('keydown-SPACE', () => {
      this.scene.start('GameScene', { stageIndex: 0, score: 0, combo: 0 });
    });
  }
}

// Phaser config
const config = {
  type: Phaser.AUTO,
  width: GAME_WIDTH,
  height: GAME_HEIGHT,
  parent: 'game-container',
  backgroundColor: '#1a1a2e',
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { y: 0 },
      debug: false,
    },
  },
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
  },
  scene: [TitleScene, GameScene],
};

const game = new Phaser.Game(config);
</script>
</body>
</html>
