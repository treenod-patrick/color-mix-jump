<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Mix Jump</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #1a1a2e; touch-action: none; }
#game-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
canvas { display: block; max-width: 100%; max-height: 100%; }
</style>
</head>
<body>
<div id="game-container"></div>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
<script>
// === Color Mix Jump ===
// Doodle Jump style hyper-casual: bounce on colored platforms, mix RYB colors, match the target!

const GW = 400;
const GH = 700;
const PLAT_COUNT = 10;
const JUMP_VEL = -620;
const GRAVITY = 900;
const MOVE_SPEED = 280;

// RYB color system
const C = {
  red:    { hex: 0xff6b6b, name: 'ë¹¨ê°•', css: '#ff6b6b' },
  yellow: { hex: 0xffd43b, name: 'ë…¸ë‘', css: '#ffd43b' },
  blue:   { hex: 0x339af0, name: 'íŒŒë‘', css: '#339af0' },
  orange: { hex: 0xff922b, name: 'ì£¼í™©', css: '#ff922b' },
  green:  { hex: 0x51cf66, name: 'ì´ˆë¡', css: '#51cf66' },
  purple: { hex: 0xbe4bdb, name: 'ë³´ë¼', css: '#be4bdb' },
  none:   { hex: 0xdddddd, name: 'ë¬´ìƒ‰', css: '#dddddd' },
  muddy:  { hex: 0x8b7355, name: 'íƒí•œìƒ‰', css: '#8b7355' },
};

const PRIMARIES = ['red', 'yellow', 'blue'];

function mixColors(c1, c2) {
  if (c1 === 'none') return c2;
  if (c2 === 'none') return c1;
  if (c1 === c2) return c1;
  const pair = [c1, c2].sort().join('+');
  return { 'blue+red': 'purple', 'red+yellow': 'orange', 'blue+yellow': 'green' }[pair] || 'muddy';
}

const STAGES = [
  { target: 'purple', hint: 'ë¹¨ê°• + íŒŒë‘', num: 1 },
  { target: 'orange', hint: 'ë¹¨ê°• + ë…¸ë‘', num: 2 },
  { target: 'green',  hint: 'íŒŒë‘ + ë…¸ë‘', num: 3 },
  { target: 'purple', hint: 'ë¹¨ê°• + íŒŒë‘', num: 4, hard: true },
  { target: 'orange', hint: 'ë¹¨ê°• + ë…¸ë‘', num: 5, hard: true },
  { target: 'green',  hint: 'íŒŒë‘ + ë…¸ë‘', num: 6, hard: true },
];

// â”€â”€â”€ GAME SCENE â”€â”€â”€
class GameScene extends Phaser.Scene {
  constructor() { super('GameScene'); }

  init(data) {
    this.stageIdx = data.stageIdx || 0;
    this.score = data.score || 0;
    this.combo = data.combo || 0;
  }

  create() {
    this.stage = STAGES[this.stageIdx % STAGES.length];
    this.playerColor = 'none';
    this.gameOver = false;
    this.cameraMinY = 0; // camera only scrolls up

    this.drawBackground();
    this.drawStars();

    // Platform group (static)
    this.platforms = this.physics.add.staticGroup();
    this.platformVisuals = [];

    // Starting platform (wide, neutral)
    this.addPlatform(GW / 2, GH - 80, 'none', 130);

    // Generate colored platforms going up
    this.topPlatY = GH - 80;
    for (let i = 0; i < PLAT_COUNT; i++) {
      const gap = this.stage.hard ? Phaser.Math.Between(100, 145) : Phaser.Math.Between(85, 125);
      this.topPlatY -= gap;
      const px = Phaser.Math.Between(55, GW - 55);
      this.addPlatform(px, this.topPlatY, Phaser.Math.RND.pick(PRIMARIES), 80);
    }

    // Goal platform
    this.topPlatY -= 130;
    this.goalPlat = this.addPlatform(GW / 2, this.topPlatY, 'goal', 110);

    // Player
    this.createPlayer(GW / 2, GH - 115);

    // Collider â€” one-way platforms: only collide when player is falling down
    this.physics.add.collider(this.player, this.platforms, this.onLand, this.canLand, this);

    // Controls
    this.setupInput();

    // UI (fixed to camera)
    this.createUI();

    // Camera
    this.cameras.main.setBounds(0, this.topPlatY - 300, GW, GH - this.topPlatY + 600);
    this.cameraMinY = this.cameras.main.scrollY;
  }

  // â”€â”€ Background â”€â”€
  drawBackground() {
    const g = this.add.graphics();
    const totalH = GH * 4;
    for (let i = 0; i < totalH; i++) {
      const t = i / totalH;
      const r = Math.round(Phaser.Math.Interpolation.Linear([230, 180, 140], t));
      const gv = Math.round(Phaser.Math.Interpolation.Linear([200, 190, 200], t));
      const b = Math.round(Phaser.Math.Interpolation.Linear([255, 240, 255], t));
      g.fillStyle(Phaser.Display.Color.GetColor(r, gv, b));
      g.fillRect(0, -GH * 3 + i, GW, 1);
    }
    g.setScrollFactor(0.3);

    for (let i = 0; i < 10; i++) {
      const cloud = this.add.ellipse(
        Phaser.Math.Between(20, GW - 20),
        Phaser.Math.Between(-GH * 2, GH),
        Phaser.Math.Between(80, 160),
        Phaser.Math.Between(30, 60),
        0xffffff, 0.2
      );
      cloud.setScrollFactor(0.15);
    }
  }

  drawStars() {
    for (let i = 0; i < 25; i++) {
      const s = this.add.circle(
        Phaser.Math.Between(5, GW - 5),
        Phaser.Math.Between(-GH * 3, GH),
        Phaser.Math.Between(1, 3),
        0xffffff,
        Phaser.Math.FloatBetween(0.2, 0.7)
      );
      s.setScrollFactor(0.35);
      this.tweens.add({
        targets: s, alpha: 0.05,
        duration: Phaser.Math.Between(800, 2500),
        yoyo: true, repeat: -1,
      });
    }
  }

  // â”€â”€ Platform â”€â”€
  addPlatform(x, y, color, w) {
    const h = 20;
    const isGoal = color === 'goal';

    // Visual container (purely cosmetic)
    const vis = this.add.container(x, y);

    if (isGoal) {
      const tgt = C[this.stage.target];
      const glow = this.add.ellipse(0, 0, w + 24, h + 18, tgt.hex, 0.25);
      const body = this.add.ellipse(0, 0, w, h, tgt.hex, 0.9);
      const shine = this.add.ellipse(0, -3, w * 0.65, h * 0.35, 0xffffff, 0.35);
      const star = this.add.text(0, -22, 'â˜…', { fontSize: '20px', color: tgt.css }).setOrigin(0.5);
      vis.add([glow, body, shine, star]);
      this.tweens.add({ targets: glow, scaleX: 1.2, scaleY: 1.2, alpha: 0.1, duration: 900, yoyo: true, repeat: -1 });
    } else {
      const cd = color === 'none' ? { hex: 0xdddddd } : C[color];
      const body = this.add.ellipse(0, 0, w, h, cd.hex);
      const shine = this.add.ellipse(0, -3, w * 0.65, h * 0.35, 0xffffff, 0.3);
      vis.add([body, shine]);
      if (color !== 'none') {
        this.tweens.add({
          targets: vis, scaleY: { from: 1, to: 0.9 },
          duration: 1400, yoyo: true, repeat: -1, ease: 'Sine.easeInOut',
        });
      }
    }

    this.platformVisuals.push(vis);

    // Physics zone â€” same position, slightly thinner for forgiving collision
    const bodyH = 14;
    const zone = this.add.zone(x, y, w, bodyH);
    this.physics.add.existing(zone, true);
    // No setSize or setOffset â€” body matches zone exactly, centered at (x, y)
    zone.platColor = color;
    zone.isGoal = isGoal;
    zone.vis = vis;
    this.platforms.add(zone);
    return zone;
  }

  // â”€â”€ Player â”€â”€
  createPlayer(sx, sy) {
    this.player = this.add.container(sx, sy);

    this.slimeBody = this.add.ellipse(0, 0, 38, 32, C.none.hex, 0.85);
    this.slimeGlow = this.add.ellipse(0, 0, 48, 40, 0xffffff, 0.12);
    const eL = this.add.ellipse(-9, -5, 9, 12, 0xffffff, 0.95);
    const eR = this.add.ellipse(9, -5, 9, 12, 0xffffff, 0.95);
    const pL = this.add.circle(-8, -4, 3.5, 0x222222);
    const pR = this.add.circle(10, -4, 3.5, 0x222222);
    const mouth = this.add.ellipse(0, 7, 10, 4, 0x000000, 0.12);
    this.player.add([this.slimeGlow, this.slimeBody, eL, eR, pL, pR, mouth]);

    this.physics.world.enable(this.player);
    const pb = this.player.body;
    pb.setSize(34, 20);
    pb.setOffset(-17, -4);
    pb.setGravityY(GRAVITY);
    pb.setBounce(0);
    pb.setCollideWorldBounds(false);
    pb.setMaxVelocity(400, 900);
    this.player.setDepth(10);
  }

  // â”€â”€ Controls â”€â”€
  setupInput() {
    this.moveDir = 0; // -1, 0, 1

    // Touch: left half = go left, right half = go right
    this.input.on('pointerdown', (p) => {
      if (this.gameOver) return;
      this.moveDir = p.x < GW / 2 ? -1 : 1;
    });
    this.input.on('pointermove', (p) => {
      if (this.gameOver || !p.isDown) return;
      this.moveDir = p.x < GW / 2 ? -1 : 1;
    });
    this.input.on('pointerup', () => { this.moveDir = 0; });

    this.cursors = this.input.keyboard.createCursorKeys();
  }

  // â”€â”€ One-way platform check (processCallback) â”€â”€
  canLand(player, plat) {
    // Only collide when falling down AND player bottom is near/above platform top
    return player.body.velocity.y > 0 && player.body.bottom <= plat.body.top + 12;
  }

  // â”€â”€ Landing â”€â”€
  onLand(player, plat) {
    // Extra safety: only bounce when actually falling
    if (player.body.velocity.y < 10) return;

    // Auto-bounce! (Doodle Jump style)
    player.body.setVelocityY(JUMP_VEL);

    // Squash & stretch on bounce
    this.tweens.killTweensOf(this.player);
    this.tweens.add({
      targets: this.player,
      scaleX: { from: 1.25, to: 1 },
      scaleY: { from: 0.75, to: 1 },
      duration: 200, ease: 'Back.easeOut',
    });

    // Platform bounce visual
    if (plat.vis) {
      this.tweens.add({
        targets: plat.vis,
        scaleX: { from: 1.2, to: 1 },
        scaleY: { from: 0.7, to: 1 },
        duration: 250, ease: 'Back.easeOut',
      });
    }

    // Goal check
    if (plat.isGoal) {
      this.checkGoal();
      return;
    }

    // Color mixing
    const pc = plat.platColor;
    if (pc && pc !== 'none') {
      const oldColor = this.playerColor;
      this.playerColor = mixColors(this.playerColor, pc);
      this.updateSlimeColor();
      this.splashEffect(player.x, player.y + 10, C[pc].hex);

      // Score for each platform
      this.score += 10;
      if (this.scoreText) this.scoreText.setText(`${this.score}`);
    }
  }

  checkGoal() {
    if (this.gameOver) return;
    this.gameOver = true;

    const camY = this.cameras.main.scrollY;

    if (this.playerColor === this.stage.target) {
      // SUCCESS
      this.combo++;
      this.score += 200 * this.combo;
      this.cameras.main.flash(200, 200, 255, 200);
      this.successBurst(this.player.x, this.player.y);

      const t1 = this.add.text(GW / 2, camY + GH * 0.35, `ìŠ¤í…Œì´ì§€ ${this.stage.num} í´ë¦¬ì–´!`, {
        fontSize: '30px', fontFamily: 'Arial', color: '#fff',
        stroke: '#000', strokeThickness: 4,
      }).setOrigin(0.5).setDepth(100);

      const t2 = this.add.text(GW / 2, camY + GH * 0.45, `+${200 * this.combo}ì   x${this.combo} ì½¤ë³´!`, {
        fontSize: '20px', fontFamily: 'Arial', color: '#ffd43b',
        stroke: '#000', strokeThickness: 3,
      }).setOrigin(0.5).setDepth(100);

      this.tweens.add({ targets: [t1, t2], y: '-=20', alpha: 0, delay: 800, duration: 800 });

      this.time.delayedCall(1800, () => {
        this.scene.restart({ stageIdx: this.stageIdx + 1, score: this.score, combo: this.combo });
      });
    } else {
      // WRONG COLOR
      this.combo = 0;
      this.cameras.main.shake(200, 0.02);

      const t = this.add.text(GW / 2, camY + GH * 0.4, 'ìƒ‰ì´ ì•ˆ ë§ì•„!', {
        fontSize: '26px', fontFamily: 'Arial', color: '#ff6b6b',
        stroke: '#000', strokeThickness: 3,
      }).setOrigin(0.5).setDepth(100);

      this.tweens.add({ targets: t, y: '-=30', alpha: 0, duration: 1200 });

      this.time.delayedCall(800, () => {
        this.playerColor = 'none';
        this.updateSlimeColor();
        this.gameOver = false;
      });
    }
  }

  // â”€â”€ Visuals â”€â”€
  updateSlimeColor() {
    const cd = C[this.playerColor] || C.none;
    this.slimeBody.setFillStyle(cd.hex, 0.85);
    this.slimeGlow.setFillStyle(cd.hex, 0.18);
    if (this.colorDot) this.colorDot.setFillStyle(cd.hex);
    if (this.colorName) this.colorName.setText(cd.name);
  }

  splashEffect(x, y, color) {
    for (let i = 0; i < 10; i++) {
      const p = this.add.circle(x, y, Phaser.Math.Between(3, 7), color, 0.85);
      p.setDepth(8);
      const a = (Math.PI * 2 * i) / 10;
      const d = Phaser.Math.Between(25, 55);
      this.tweens.add({
        targets: p,
        x: x + Math.cos(a) * d,
        y: y + Math.sin(a) * d,
        alpha: 0, scaleX: 0.1, scaleY: 0.1,
        duration: 350, ease: 'Quad.easeOut',
        onComplete: () => p.destroy(),
      });
    }
  }

  successBurst(x, y) {
    const cols = [0xff6b6b, 0xff922b, 0xffd43b, 0x51cf66, 0x339af0, 0xbe4bdb];
    for (let i = 0; i < 24; i++) {
      const c = cols[i % cols.length];
      const p = this.add.circle(x, y, Phaser.Math.Between(4, 9), c, 0.9);
      p.setDepth(20);
      const a = (Math.PI * 2 * i) / 24;
      const d = Phaser.Math.Between(50, 130);
      this.tweens.add({
        targets: p,
        x: x + Math.cos(a) * d, y: y + Math.sin(a) * d,
        alpha: 0, duration: 900, ease: 'Quad.easeOut',
        onComplete: () => p.destroy(),
      });
    }
  }

  // â”€â”€ UI â”€â”€
  createUI() {
    const tgt = C[this.stage.target];

    // Top bar
    this.add.rectangle(GW / 2, 28, GW - 16, 48, 0x000000, 0.35).setScrollFactor(0).setDepth(50).setRoundedRectRadius(10);

    // Stage
    this.add.text(14, 12, `Stage ${this.stage.num}`, {
      fontSize: '15px', fontFamily: 'Arial', color: '#fff', fontStyle: 'bold',
    }).setScrollFactor(0).setDepth(51);

    // Target
    this.add.text(GW / 2, 11, 'ëª©í‘œ', {
      fontSize: '11px', fontFamily: 'Arial', color: '#ffffffaa',
    }).setOrigin(0.5, 0).setScrollFactor(0).setDepth(51);

    this.add.circle(GW / 2 - 18, 36, 9, tgt.hex).setScrollFactor(0).setDepth(51);
    this.add.text(GW / 2 - 4, 29, tgt.name, {
      fontSize: '14px', fontFamily: 'Arial', color: tgt.css, fontStyle: 'bold',
    }).setScrollFactor(0).setDepth(51);

    // Score
    this.scoreText = this.add.text(GW - 14, 12, `${this.score}`, {
      fontSize: '16px', fontFamily: 'Arial', color: '#ffd43b', fontStyle: 'bold',
    }).setOrigin(1, 0).setScrollFactor(0).setDepth(51);

    this.add.text(GW - 14, 32, 'ì ìˆ˜', {
      fontSize: '10px', fontFamily: 'Arial', color: '#ffffffaa',
    }).setOrigin(1, 0).setScrollFactor(0).setDepth(51);

    // Bottom: current color
    this.add.rectangle(GW / 2, GH - 28, 150, 38, 0x000000, 0.35).setScrollFactor(0).setDepth(50).setRoundedRectRadius(10);

    this.add.text(GW / 2 - 60, GH - 38, 'ë‚´ ìƒ‰:', {
      fontSize: '13px', fontFamily: 'Arial', color: '#fff',
    }).setScrollFactor(0).setDepth(51);

    this.colorDot = this.add.circle(GW / 2 + 8, GH - 28, 9, C.none.hex);
    this.colorDot.setScrollFactor(0).setDepth(51);

    this.colorName = this.add.text(GW / 2 + 22, GH - 35, C.none.name, {
      fontSize: '13px', fontFamily: 'Arial', color: '#ddd',
    }).setScrollFactor(0).setDepth(51);

    // Hint (fades out)
    const hint = this.add.text(GW / 2, GH - 65, `íŒíŠ¸: ${this.stage.hint}`, {
      fontSize: '12px', fontFamily: 'Arial', color: '#fff', alpha: 0.6,
    }).setOrigin(0.5).setScrollFactor(0).setDepth(51);
    this.tweens.add({ targets: hint, alpha: 0, delay: 3000, duration: 1000 });

    // Left/Right arrows (mobile helper)
    const arrowStyle = { fontSize: '28px', color: '#ffffff55' };
    this.add.text(30, GH / 2, 'â—€', arrowStyle).setOrigin(0.5).setScrollFactor(0).setDepth(40);
    this.add.text(GW - 30, GH / 2, 'â–¶', arrowStyle).setOrigin(0.5).setScrollFactor(0).setDepth(40);
  }

  // â”€â”€ Update â”€â”€
  update() {
    if (this.gameOver) return;

    const pb = this.player.body;

    // Horizontal movement
    let vx = 0;
    if (this.cursors.left.isDown) {
      vx = -MOVE_SPEED;
    } else if (this.cursors.right.isDown) {
      vx = MOVE_SPEED;
    } else if (this.moveDir !== 0) {
      vx = this.moveDir * MOVE_SPEED;
    }
    pb.setVelocityX(vx);

    // Wrap horizontally
    if (this.player.x < -15) this.player.x = GW + 15;
    if (this.player.x > GW + 15) this.player.x = -15;

    // Camera: only scroll UP (never down)
    const targetY = this.player.y - GH * 0.55;
    if (targetY < this.cameraMinY) {
      this.cameraMinY = Phaser.Math.Linear(this.cameraMinY, targetY, 0.13);
    }
    this.cameras.main.scrollY = this.cameraMinY;

    // Fall death: below camera bottom
    if (this.player.y > this.cameras.main.scrollY + GH + 60) {
      this.die();
    }
  }

  die() {
    if (this.gameOver) return;
    this.gameOver = true;
    this.combo = 0;
    this.cameras.main.flash(300, 255, 80, 80);

    const cy = this.cameras.main.scrollY + GH / 2;

    this.add.rectangle(GW / 2, cy, GW, GH, 0x000000, 0.4).setDepth(90);

    this.add.text(GW / 2, cy - 40, 'ë–¨ì–´ì¡Œë‹¤!', {
      fontSize: '38px', fontFamily: 'Arial', color: '#ff6b6b',
      stroke: '#000', strokeThickness: 5,
    }).setOrigin(0.5).setDepth(100);

    this.add.text(GW / 2, cy + 10, `ì ìˆ˜: ${this.score}`, {
      fontSize: '22px', fontFamily: 'Arial', color: '#fff',
      stroke: '#000', strokeThickness: 3,
    }).setOrigin(0.5).setDepth(100);

    const retry = this.add.text(GW / 2, cy + 60, 'íƒ­í•˜ì—¬ ì¬ì‹œì‘', {
      fontSize: '18px', fontFamily: 'Arial', color: '#ffd43b',
    }).setOrigin(0.5).setDepth(100);
    this.tweens.add({ targets: retry, alpha: 0.3, duration: 500, yoyo: true, repeat: -1 });

    this.time.delayedCall(600, () => {
      this.input.once('pointerdown', () => {
        this.scene.restart({ stageIdx: this.stageIdx, score: 0, combo: 0 });
      });
      this.input.keyboard.once('keydown-SPACE', () => {
        this.scene.restart({ stageIdx: this.stageIdx, score: 0, combo: 0 });
      });
    });
  }
}

// â”€â”€â”€ TITLE SCENE â”€â”€â”€
class TitleScene extends Phaser.Scene {
  constructor() { super('TitleScene'); }

  create() {
    // BG gradient
    const g = this.add.graphics();
    for (let i = 0; i < GH; i++) {
      const t = i / GH;
      const r = Math.round(Phaser.Math.Interpolation.Linear([224, 142], t));
      const gv = Math.round(Phaser.Math.Interpolation.Linear([195, 197], t));
      const b = Math.round(Phaser.Math.Interpolation.Linear([252, 252], t));
      g.fillStyle(Phaser.Display.Color.GetColor(r, gv, b));
      g.fillRect(0, i, GW, 1);
    }

    // Floating circles
    const dcols = [0xff6b6b, 0xffd43b, 0x339af0, 0xbe4bdb, 0xff922b, 0x51cf66];
    for (let i = 0; i < 15; i++) {
      const c = this.add.circle(
        Phaser.Math.Between(20, GW - 20),
        Phaser.Math.Between(60, GH - 60),
        Phaser.Math.Between(12, 35),
        dcols[i % dcols.length], 0.18
      );
      this.tweens.add({
        targets: c,
        y: c.y + Phaser.Math.Between(-50, 50),
        x: c.x + Phaser.Math.Between(-25, 25),
        duration: Phaser.Math.Between(2500, 5000),
        yoyo: true, repeat: -1, ease: 'Sine.easeInOut',
      });
    }

    // Title
    const title = this.add.text(GW / 2, 185, 'Color Mix\nJump', {
      fontSize: '54px', fontFamily: 'Arial', color: '#fff',
      stroke: '#be4bdb', strokeThickness: 6, align: 'center', lineSpacing: 10,
    }).setOrigin(0.5);
    this.tweens.add({
      targets: title, scaleX: 1.04, scaleY: 1.04,
      duration: 1800, yoyo: true, repeat: -1, ease: 'Sine.easeInOut',
    });

    this.add.text(GW / 2, 300, 'ìƒ‰ê¹” ë°œíŒì„ ë°Ÿì•„ ëª©í‘œ ìƒ‰ìƒì„ ë§Œë“¤ì–´ìš”!', {
      fontSize: '14px', fontFamily: 'Arial', color: '#ffffffcc',
    }).setOrigin(0.5);

    // Color demo
    const dy = 365;
    this.add.circle(GW / 2 - 65, dy, 18, C.red.hex);
    this.add.text(GW / 2 - 33, dy - 8, '+', { fontSize: '20px', color: '#fff' }).setOrigin(0.5);
    this.add.circle(GW / 2, dy, 18, C.blue.hex);
    this.add.text(GW / 2 + 33, dy - 8, '=', { fontSize: '20px', color: '#fff' }).setOrigin(0.5);
    this.add.circle(GW / 2 + 65, dy, 18, C.purple.hex);

    // Slime preview
    const sy = 450;
    const slime = this.add.ellipse(GW / 2, sy, 52, 42, 0xbe4bdb, 0.85);
    this.add.ellipse(GW / 2 - 11, sy - 6, 10, 14, 0xffffff, 0.95);
    this.add.ellipse(GW / 2 + 11, sy - 6, 10, 14, 0xffffff, 0.95);
    this.add.circle(GW / 2 - 10, sy - 5, 4, 0x222222);
    this.add.circle(GW / 2 + 12, sy - 5, 4, 0x222222);
    this.tweens.add({
      targets: slime, y: sy - 15,
      duration: 600, yoyo: true, repeat: -1, ease: 'Quad.easeOut',
    });

    // Start button
    const btn = this.add.rectangle(GW / 2, 545, 200, 54, 0xbe4bdb, 0.9).setInteractive({ useHandCursor: true });
    btn.postFX?.addShine?.(0.3);
    this.add.text(GW / 2, 545, 'ì‹œì‘í•˜ê¸° â–¶', {
      fontSize: '22px', fontFamily: 'Arial', color: '#fff', fontStyle: 'bold',
    }).setOrigin(0.5);
    this.tweens.add({
      targets: btn, scaleX: 1.06, scaleY: 1.06,
      duration: 900, yoyo: true, repeat: -1, ease: 'Sine.easeInOut',
    });

    const startGame = () => this.scene.start('GameScene', { stageIdx: 0, score: 0, combo: 0 });
    btn.on('pointerdown', startGame);
    this.input.keyboard.on('keydown-SPACE', startGame);

    // Controls hint
    this.add.text(GW / 2, 600, 'í™”ë©´ ì™¼ìª½/ì˜¤ë¥¸ìª½ í„°ì¹˜ë¡œ ì´ë™ | ìë™ ì í”„!', {
      fontSize: '11px', fontFamily: 'Arial', color: '#ffffff88',
    }).setOrigin(0.5);

    // Credits
    this.add.text(GW / 2, GH - 18, 'ğŸ° ì¸„ë¦­í•‘ + ğŸ¦Š ê·¸ë¦¼í•‘ + ğŸ¥ ë§‰ë‚´í•‘', {
      fontSize: '11px', fontFamily: 'Arial', color: '#ffffff66',
    }).setOrigin(0.5);
  }
}

// â”€â”€â”€ CONFIG â”€â”€â”€
new Phaser.Game({
  type: Phaser.AUTO,
  width: GW,
  height: GH,
  parent: 'game-container',
  backgroundColor: '#1a1a2e',
  physics: {
    default: 'arcade',
    arcade: { gravity: { y: 0 }, debug: false },
  },
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
  },
  scene: [TitleScene, GameScene],
});
</script>
</body>
</html>
